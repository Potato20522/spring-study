## C#中async/await

https://www.cnblogs.com/zhaoshujie/p/11192036.html

用`async`来修饰一个方法，表明这个方法是异步的，声明的方法的返回类型必须为：`void`或`Task`或`Task<TResult>`。方法内部必须含有`await`修饰的方法，如果方法内部没有`await`关键字修饰的表达式，哪怕函数被`async`修饰也只能算作同步方法，执行的时候也是同步执行的。

被await修饰的只能是`Task`或者`Task<TResule>`类型，通常情况下是一个返回类型是`Task/Task<TResult>`的方法，当然也可以修饰一个`Task/Task<TResult>`变量，await只能出现在已经用async关键字修饰的异步方法中。上面代码中就是修饰了一个变量`ResultFromTimeConsumingMethod`。

关于被修饰的对象，也就是返回值类型是`Task`和`Task<TResult>`函数或者`Task/Task<TResult>`类型的变量：如果是被修饰对象的前面用`await`修饰，那么返回值实际上是`void`或者`TResult`（示例中`ResultFromTimeConsumingMethod`是`TimeConsumingMethod()`函数的返回值，也就是`Task<string>`类型，当`ResultFromTimeConsumingMethod`在前面加了`await`关键字后 `await ResultFromTimeConsumingMethod`实际上完全等于 `ResultFromTimeConsumingMethod.Result`）。如果没有`await`，返回值就是`Task`或者`Task<TResult>`。



https://blog.csdn.net/weixin_30245867/article/details/96900776

在.NET4.5中，我们可以配合使用async和await两个关键字，来以写同步代码的方式，实现异步的操作。

好处我目前看来有两点：

1.**不会阻塞UI线程**。一旦UI线程不能及时响应，会极大的影响用户体验，这点在手机和平板的APP上尤为重要。

2.代码简洁。

- 相对基于event的异步方式，在多次回调的情况下（比如需要多次调web service，且后续调用基于前次调用的结果）特别明显。可以将多个+=Completed方法合并到一起。
- 相对于Begin/End的异步方式，避免了N重且不能对齐的大括号。

## javascript 中 async/await

https://www.cnblogs.com/lonelyshy/p/13726674.html

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function

`async`和`await`关键字让我们可以用一种更简洁的方式写出基于[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的异步行为，而无需刻意地链式调用`promise`。



## java中的异步

。。。。。。



## Springboot @Async

https://www.cnblogs.com/huanzi-qch/p/11231041.html

大致步骤：

- 启动类加入@EnableAsync 开启异步调用
- 业务方法返回Future且标注 @Async("asyncTaskExecutor")，asyncTaskExecutor是自定义的线程池
- 配置线程池 asyncTaskExecutor

注意点：https://www.cnblogs.com/baixianlong/p/10661591.html

- 在默认情况下，未设置TaskExecutor时，默认是使用SimpleAsyncTaskExecutor这个线程池，但此线程不是真正意义上的线程池，因为线程不重用，每次调用都会创建一个新的线程。可通过控制台日志输出可以看出，每次输出线程名都是递增的。所以最好我们来自定义一个线程池。
- 调用的异步方法，不能为同一个类的方法（包括同一个类的内部类），简单来说，因为Spring在启动扫描时会为其创建一个代理类，而同类调用时，还是调用本身的代理类的，所以和平常调用是一样的。其他的注解如@Cache等也是一样的道理，说白了，就是Spring的代理机制造成的。所以在开发中，最好把异步服务单独抽出一个类来管理。下面会重点讲述。。

失效的情况：

1. 调用同一个类下注有@Async异步方法：在spring中像@Async和@Transactional、cache等注解本质使用的是动态代理，其实Spring容器在初始化的时候Spring容器会将含有AOP注解的类对象“替换”为代理对象（简单这么理解），那么注解失效的原因就很明显了，就是因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器，那么解决方法也会沿着这个思路来解决。
2. 调用的是静态(static )方法
3. 调用(private)私有化方法

针对失效1的情况解决：

1. 将要异步执行的方法单独抽取成一个类，原理就是当你把执行异步的方法单独抽取成一个类的时候，这个类肯定是被Spring管理的，其他Spring组件需要调用的时候肯定会注入进去，这时候实际上注入进去的就是代理类了。
2. 其实我们的注入对象都是从Spring容器中给当前Spring组件进行成员变量的赋值，由于某些类使用了AOP注解，那么实际上在Spring容器中实际存在的是它的代理对象。那么我们就可以通过上下文获取自己的代理对象调用异步方法。